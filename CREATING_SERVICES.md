# Creating new services

The best reference manual for creating new services right now will be an [`cryptocurrency` example](https://github.com/popzxc/exonum-python-backend/tree/master/examples/cryptocurrency).

However, here's the list of the main points:

1. Your service must derive `Service` interface class.

    Prerequirements:
    - In the service moulde there should be an `proto` submodulemodule which contain `service_pb2.py`
      generated by `protoc`. It will be used for transactions and config deserialization.

    Creating your own service, you should do the following:

    - Create a class which is a subclass of `Service`.
    - Implement `proto_sources` method.
    - Implement `initialize` method (see the description of it).
    - Implement several transactions handlers and wrap them into `@Service.transaction` decorator
      (see the description of this decorator).
    - Either derive `WithSchema` or implement `state_hash` function.
    - Implement `wire_api` method.
    - Optionally: implement `before_commit` and `after_commit` method.

    Errors raised by subclass of `Service` must be derived from `ServiceError`. Raising an error which is
    not derived from `ServiceError` will be considered an error in the service implementation, and such
    a service will be disabled.
    Please note that raising `ServiceError` is allowed only when some input data is provided, namely in
    the `initialize` and `execute` methods. All the other methods aren't allowed to raise any kind of
    exception, so you have to handle it by yourself.

    Example of service:

    ```python
    class MyService(Service, WithSchema):
        _schema_ = MySchema
        _state_hash_ = ["some_index", "some_other_index"]
        def initialize(self, _fork: Fork, _config: service_pb2.Config) -> None:
            pass
        @classmethod
        def proto_sources(cls) -> ArtifactProtobufSpec:
             return my_impl_load_protobuf_spec()
        @MyService.transaction(tx_id=0, tx_name="MyTx")
        def my_tx_handler(self, _context: TransactionContext, _tx: service_pb2.MyTx) -> None:
            pass
        @MyService.transaction(tx_id=1, tx_name="MyTx2")
        def my_tx_erroring_handler(self, _context: TransactionContext, _tx: service_pb2.MyTx2) -> None:
            raise MyServiceError(code=22) # MyServiceError is derived from ServiceError
    ```

2. If your service needs a schema (which is probably true), it should also derive `WithSchema`.
  
    Classes deriving `WithSchema` should provide two class attributes:
    - `_schema_` -- the class which is inherited from the `Schema` class (see below).
    - `_state_hash_` -- list of Proof*Index names from schema which should be included into state hash calculation.

    Classes derived from `Schema` should provide fields via type annotations, like `index_name: ProofListIndex[KeyType]`.

    Keys and values that will be should be derived from the `IntoBytes`.

    E.g.:

    ```python
    class SomeBinaryData(IntoBytes):
        def __init__(self, value: bytes):
            self.value = value
        def into_bytes(self) -> bytes:
            return self.value
        @classmethod
        def from_bytes(cls, data: bytes) -> bytes:
            return cls(data)

    class SomeSchema(Schema):
        # Specification of the stored types will be used for automatical (de)serialization.
        some_data: MapIndex[SomeBinaryData, SomeBinaryData]
        some_other_data: ProofListIndex[SomeBinaryData]

    class ServiceWithSchema(Service, WithSchema):
        __schema__ = SomeSchema
        __state_hash_ = ["some_other_data"]

        # ...

        def before_commit(self, fork: Fork) -> None:
            schema = self.schema(fork)

            some_data = schema.some_data(family="some_family")

            # Write access works like usual python dict/list structures.
            some_data[SomeBinaryData(b"123")] = SomeBinaryData(b"456")

            some_other_data = schema.some_other_data()

            # Hash of merkelized structures can be obtained via `object_hash` method.
            print(some_other_data.object_hash())
    ```

3. If your service provides an API, you should create a class derived from `ServiceApi`.

    Classes that inherit `ServiceApi` should implement two methods: `public_endpoints` and `private_endpoints`.
    The only difference between those two is that the first should provide a public interface which can
    be accessed by everybody, and the second should provide an administrative interface.

    Those methods should return a description of api for the service in the following format:

    ```python
    {
        r"endpoint/": {
            "http_method_name": handler_function
        }
    }
    ```

    For example:

    ```python
    {
        r"/": {
            "get": main_get,
            "post": main_post,
        },
        r"/info/(\d+)": {
            "get": info_get,
        }
    }
    ```

    Handlers are async functions which return either a `dict` (in case of successfull API call), or `None`
    (if API call cannot be executed). If `dict` was returned, the status code of response will be OK and
    response will contain returned value as JSON. Otherwise, response status code will be BAD_REQUEST.

    If service was able to process the API request, but however it turned out to be erroneous, it's recommended
    to return a dict like `{"error": "description"}`.

    Types of HTTP methods that are currently supported: "get", "post", "put", "delete".
    For "get" and "delete" methods your handler should accept at least one argument of type `ServiceApiContext`.
    For "post" and "put" methods your handler should accept at least two arguments: `ServiceApiContext` and dict
    value of deserialized `json` from request payload.

    If endpoint contains variables (like `r"/info/(\d+)"` in the example above), those parameters will be passed
    after the mandatory arguments defined above.

    So, the expected signature for POST method of "/" endpoint from the example above would be

    ```python
    async def main_post(context: ServiceApiContext, payload: Dict[str, Any]) -> Dict[Any, Any]
    ```

    and for GET method of "/info/(\d+)" endpoint it would be:

    ```python
    async def info_get(context: ServiceApiContext, query_string_parameter: str) -> Dict[Any, Any]
    ```
